---
title: "Bioproject RNAseq: COVID 19"
author: Ramos Galguera Johana Itzel, Marín Peralta Alejandro Efraín, Talavera Cruz
  María Fernanda
date: "`r Sys.Date()`"
output: 
  html_document:
    toc: true
    toc_float:
      toc_collapsed: true
    toc_depth: 3
    number_sections: true
    theme: lumen
---

Este reporte, así como su versión en PDF y HTML, y todos los archivos usados para
su creación están disponibles en 
[GitHub](https://github.com/Bioinfo-Equipo/RNA-seq).


# Descripción de los datos

<table class="table table-bordered">
  <tbody>
    <tr>
      <td>Bioproject</td>
      <td>[PRJNA858106](https://www.ncbi.nlm.nih.gov/bioproject/PRJNA858106) </td>
    </tr>
    <tr>
      <td>Especie</td>
      <td>*Homo sapiens* </td>
    </tr>
    <tr>
      <td>Tipo de bibliotecas</td>
      <td>*Paired-end* </td>
    </tr>
    <tr>
      <td>Método de selección</td>
      <td>.</td>
    </tr>
    <tr>
      <td>Número de transcriptomas</td>
      <td>10</td>
    </tr>
    <tr>
      <td>Número de réplicas biológicas</td>
      <td>10 (3 controles y 7 casos)</td>
    </tr>
    <tr>
      <td>Secuenciador</td>
      <td>Illumina NovaSeq 6000 (Homo sapiens)</td>
    </tr>
    <tr>
      <td>Distribución de las muestras  (SRA)</td>
      <td>SRR20114180 (Control-1), SRR20114179 (Control-2), SRR20114178 (Control-3), SRR20114177 (Patient-1), SRR20114176 (Patient-2), SRR20114175 (Patient-3), SRR20114174 (Patient-4), SRR20114173 (Patient-5), SRR20114172 (Patient-6) y SRR20114171 (Patient-7)</td>
    </tr>
    <tr>
      <td>Profundidad de secuenciación de cada transcriptoma</td>
      <td>.</td>
    </tr>
  </tbody>
</table>

# Resumen




# Métodos 

## Análisis de calidad de las lecturas y limpieza de adaptadores



### Análisis de  *raw data*

Para el análisis de calidad se usó fastqc de manera individual para cada data set
del SRA, y después se usó multiqc para visualizar en conjunto todos los resultados.


###  Limpieza de adaptadores

Para limpiar los adaptadores se usó el software trimmomatic en el siguiente 
bash script:

```
cd data
for i in *_1.fastq.gz;
do echo
trimmomatic PE -threads 8 -phred33 $i "${i%_1.fastq.gz}_2.fastq.gz" \
../data_trimmed/"${i%_1.fastq.gz}_1_trimmed.fastq.gz" ../data_trimmed/"${i%_1.fastq.gz}_1_unpaired.fastq.gz" \
../data_trimmed/"${i%_1.fastq.gz}_2_trimmed.fastq.gz" ../data_trimmed/"${i%_1.fastq.gz}_2_unpaired.fastq.gz" \
ILLUMINACLIP:../TruSeq3-PE.fa:2:30:10 LEADING:3 TRAILING:3 SLIDINGWINDOW:5:20 MINLEN:60
done
```

El script no es tan complicado, donde:

- ```./data``` es el directorio con todos los archivos crudos descargados de SRA.
- ```PE``` es para decir que el input sera un archivo paired end.
- ```phred33``` especifica la calidad de las bases.
- ```threads``` indica el número de núcleos que se van a utilizar.
- ```ILLUMINACLIP``` es para indicar los adaptadores y otras secuencias específicas de illumina.
- ```LEADING``` es para cortar las bases del comienzo de una lectura, si está por debajo de un umbral de calidad.
- ```TRAILING``` es para cortar las bases del final de una lectura, si está por debajo de un umbral de calidad.
- ```SLIDINGWINDOW``` recorta la lectura una vez que la calidad promedio dentro de la ventana cae por debajo de un umbral.
- ```MINLEN``` descarta la lectura si está por debajo de una longitud especificada.



### Analisis de calidad de las lecturas sin adaptadores

Se realizó el mismo procedimiento que con los datos crudos.


## Ensamblaje con el transcriptoma de referencia

Descargamos el transcriptoma de referencia en el directorio donde 
se correra kallisto, *i. e.*, en 
```/mnt/Timina/bioinfoII/rnaseq/BioProject_2023/rawData/COVID_virus``` con wget:

```
wget https://ftp.ebi.ac.uk/pub/databases/gencode/Gencode_human/release_43/gencode.v43.transcripts.fa.gz
```

Después, generamos el index de Kallisto con
```
kallisto index -i ./kallisto_quant/Hs_ref.kidx gencode.v43.transcripts.fa.gz
```

Posteriormente, se crearon directorios individuales para cada muestra dentro de 
```./kallisto_quant/```, ya que kallisto solo trabaja individualmente con cada
par de lecturas.

El pseudoalineamiento y cuantificacióncon kallisto se realizó para cada muestra con la siguiente
estructura:

```
kallisto quant -i ./kallisto_quant/Hs_ref.kidx -o ./kallisto_quant/SRR20114171 -t 25 ./data_trimmed/SRR20114171_1_trimmed.fastq.gz ./data_trimmed/SRR20114171_2_trimmed.fastq.gz
```

Donde ```-i``` indica el índice, ```-o``` el directorio de salido, ```-t```
el número de núcleos a usar y los otros dos archivos son el par de reads.

El output de kallisto son tres archivos: un json llamado ```un_info.json```,
un archivo de texto con las estimaciones de la abundancia llamado
```abundance.tsv``` y un archivo binario con información de la corrida, estimación
de la abundancia, estimados de bootstrap y longitud de los transcritos llamado
```abundance.h5 ```.


## Expresión diferencial

### Efra


```{r echo=FALSE}
library(tximport)
library(tidyverse)
library(DESeq2)
library(ggplot2)
library(ggrepel) # libreria que evita el overlap de texto en labels
library(rhdf5)
```


```{r}
files = file.path("/home/emp/Documents/LCG/4th/Bioinfo/github/RNA-seq/kallisto_quant",
             list.dirs("/home/emp/Documents/LCG/4th/Bioinfo/github/RNA-seq/kallisto_quant"),
             "abundance.h5")
names(files) = str_extract(files, "SRR\\d+")

txi.kallisto.tsv = tximport(files, type = "kallisto", tx2gene = tx2gene,
                            ignoreAfterBar = TRUE)
```


### Fer


```{r}
# generar tabla de metadatos

Hs_metadata.tsv = data.frame(
  "SRA" = c("SRR20114180","SRR20114179", "SRR20114178", "SRR20114177",
            "SRR20114176","SRR20114175", "SRR20114174", "SRR20114173",
            "SRR20114172", "SRR20114171"), 
  "sample" = c("control_1","control_2","control_3", "patient_1", "patient_2", 
               "patient_3", "patient_4", "patient_5", "patient_6", "patient_7"),
  "dex" = c(rep("control",3), rep("patient",7)), "species" = "Homo_sapiens")
```

```{r}
# Anotacion articulo
# Cargar los archivos por nombre del archivo (ubicacion empleando la anotacion de los 224 transcriptomas) 
Hs_samples <- Hs_metadata.tsv
Hs_files   <- file.path("./kallisto_quant", Hs_samples$SRA,"abundance.tsv")
names(Hs_files) <- Hs_samples$SRA
```

```{r}
# Load table with trx id and gene id corrspondence
#tx2gene <- read.csv("gencode.vM28.basic.trx_id-gene_id-no_ver.tsv",
                    stringsAsFactors = F)

# Run tximport
# tx2gene links transcript IDs to gene IDs for summarization
txi.kallisto <- tximport(Hs_files, type = "kallisto_quant", tx2gene = tx2gene,
                         ignoreAfterBar=TRUE, ignoreTxVersion=TRUE)

```

```{r}
names(txi.kallisto)
```

```{r}
head(txi.kallisto$counts)
```
```{r}
# nombre de los transcriptomas
rownames(Hs_samples) <- Hs_samples$sample
colnames(txi.kallisto$counts) <-rownames(Hs_samples) 
```

```{r}
# Importacion de los datos convirtiendolos en un objeto que puede leer Deseq.
ddsTxi_all <- DESeqDataSetFromTximport(txi.kallisto, Hs_samples, design = ~ dex) # Create a DESeq object from the tximport data

# Prefiltrado, eliminacion de genes con bajas cuentas
keep                <- rowSums(counts(ddsTxi_all)) >= 10
ddsTxi_all       <- ddsTxi_all[keep,] 
dds_all          <- DESeq(ddsTxi_all) # run Differential expression analysis 
```
### Cuentas normalizadas para graficas (rlog)
```{r}
all_normalized <- rlog(dds_all, blind=FALSE) # result rld, vst
all_normalized_db <- as.data.frame(assay(all_normalized))
head(all_normalized_db)
```

**PCA**
```{r}
plotPCA(all_normalized, intgroup=c("dex"))
```

### Expresion diferencial (TODOS LOS TRANSCRITOS)
```{r}
res_all                              <- results(dds_all)  # Save the results
mcols(res_all)$description # contraste shoot vs root
#https://github.com/COMBINE-lab/salmon/issues/581

# extraer UP
all_de_gene_matrix_UP  <- subset(res_all, padj < 0.05 & log2FoldChange >= 0.5)
write.table(all_de_gene_matrix_UP,file ="./DE_files/all_DEG_kallisto_BlueLight.tsv",
            quote=FALSE, sep="\t")
# Extraer nombres
all_de_gene_names_UP <- rownames(all_de_gene_matrix_UP)

# extraer down genes
all_de_gene_matrix_DOWN  <- subset(res_all, padj < 0.05 & log2FoldChange < -0.5)
write.table(all_de_gene_matrix_DOWN,file ="./all_DEG_kallisto_Control.tsv",
            quote=FALSE, sep="\t")
# Extraer nombres
all_de_gene_names_DOWN <- rownames(all_de_gene_matrix_DOWN)

# Numero de genes expresados
length(all_de_gene_names_UP)
length(all_de_gene_names_DOWN)
```
### volcano plot
```{r}
de <- as.data.frame(res_all)
# add a column of NAs
de$diffexpressed <- "NO"

# if log2Foldchange > 0.6 and pvalue < 0.05, set as "UP" 
de$diffexpressed[de$log2FoldChange > 0.6 & de$pvalue < 0.05] <- "UP"
# if log2Foldchange < -0.6 and pvalue < 0.05, set as "DOWN"
de$diffexpressed[de$log2FoldChange < -0.6 & de$pvalue < 0.05] <- "DOWN"
# Create a new column "names" to de, that will contain the name of a subset if genes differentially expressed (NA in case they are not)
de$names <- NA
# filter for a subset of interesting genes
filter <- which(de$diffexpressed != "NO" & de$padj < 0.05 & (de$log2FoldChange >= 5  | de$log2FoldChange <= -5))
de$names[filter] <- rownames(de)[filter]

# grafica
png(file = "volcano-covid.png",
    width = 800, height = 800) # guardar el plot en formato png
ggplot(data=de, aes(x=log2FoldChange, y=-log10(pvalue), col=diffexpressed,
                    label=names)) +
    geom_point() +
    scale_color_manual(values=c("blue", "black", "red")) + # cambiar colores de puntos
    theme_minimal() +
    geom_text_repel() +
    xlim(-15,15)

dev.off()
```

### Heatmap
```{r}
library("pheatmap")
# los primeros 20 genes
select <- order(rowMeans(counts(dds_all,normalized=TRUE)),
                decreasing=TRUE)[1:20]
df <- as.data.frame(colData(dds_all)[,c("dex", "sample")])

#heatmap
pheatmap(assay(all_normalized)[select,], cluster_rows=FALSE,
         show_rownames=FALSE, cluster_cols=FALSE, annotation_col=df)
```

# Resultados

## Análisis de calidad de datos crudos


Todo el resumen de la calidad de los datos crudos se encuentra [aquí](QC/QC_rawData/multiqc_report.html).


Todos los resultados se encuentran dentro del DNA HPCC en la ruta
```/mnt/Timina/bioinfoII/rnaseq/BioProject_2023/rawData/COVID_virus/FastQC_rawData.```




## Análisis de calidad de los datos sin adaptadores


Como podemos ver en la siguiente gráfica, la calidad media de cada base de
las reads es en general buena.

![](QC/QC_trimmedData/fastqc_per_base_sequence_quality_plot.png)


También podemos ver que la calidad media de las *reads* igualmente es buena.

![](QC/QC_trimmedData/fastqc_per_sequence_quality_scores_plot.png)

El contenido de GC es complicado, pero como estamos analizando datos de 
transcripción, toleraremos que hayan varios picos y distribuciones no normales.

![](QC/QC_trimmedData/fastqc_per_sequence_gc_content_plot.png)


La calidad de secuenciación es de un nivel tal que la existencia lecturas N 
es casi nula.


![](QC/QC_trimmedData/fastqc_per_base_n_content_plot.png)


La longitud de las secuencias si bien no es perfecta, es aceptable. Además, 
son secuencias largas, por lo que el alineamiento será mejor.

![](QC/QC_trimmedData/fastqc_sequence_length_distribution_plot.png)


En cuanto a lecturas duplicadas, hay muchas que se repiten; lo cual tiene sentido,
ya que estamos anlizando datos de transcripción.

![](QC/QC_trimmedData/fastqc_sequence_duplication_levels_plot.png)

Todos los resultados, tanto individuales de cada fastqc como del multiqc, se encuentran
dentro del DNA HPCC en la ruta
```/mnt/Timina/bioinfoII/rnaseq/BioProject_2023/rawData/COVID_virus/FastQC_trimmed```


# Discusión







