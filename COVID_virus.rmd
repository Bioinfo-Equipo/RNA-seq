---
title: "Bioproject RNAseq: COVID 19"
author: Ramos Galguera Johana Itzel, Marín Peralta Alejandro Efraín, Talavera Cruz
  María Fernanda
date: "`r Sys.Date()`"
output: 
  html_document:
    toc: true
    toc_float:
      toc_collapsed: true
    toc_depth: 3
    number_sections: true
    theme: lumen
---

Este reporte, así como su versión en PDF y HTML, y todos los archivos usados para
su creación están disponibles en 
[GitHub](https://github.com/Bioinfo-Equipo/RNA-seq).


# Descripción de los datos

<table class="table table-bordered">
  <tbody>
    <tr>
      <td>Bioproject</td>
      <td>[PRJNA858106](https://www.ncbi.nlm.nih.gov/bioproject/PRJNA858106) </td>
    </tr>
    <tr>
      <td>Especie</td>
      <td>*Homo sapiens* </td>
    </tr>
    <tr>
      <td>Tipo de bibliotecas</td>
      <td>*Paired-end* </td>
    </tr>
    <tr>
      <td>Método de selección</td>
      <td>Ribo-zero</td>
    </tr>
    <tr>
      <td>Número de transcriptomas</td>
      <td>1 (Gencode v43)</td>
    </tr>
    <tr>
      <td>Número de réplicas biológicas</td>
      <td>10 (3 controles y 7 casos)</td>
    </tr>
    <tr>
      <td>Secuenciador</td>
      <td>Illumina NovaSeq 6000 (Homo sapiens)</td>
    </tr>
    <tr>
      <td>Distribución de las muestras  (SRA)</td>
      <td>SRR20114180 (Control-1), SRR20114179 (Control-2), SRR20114178 (Control-3), SRR20114177 (Patient-1), SRR20114176 (Patient-2), SRR20114175 (Patient-3), SRR20114174 (Patient-4), SRR20114173 (Patient-5), SRR20114172 (Patient-6) y SRR20114171 (Patient-7)</td>
    </tr>
    <tr>
      <td>Profundidad de secuenciación de cada transcriptoma</td>
      <td>.</td>
    </tr>
  </tbody>
</table>

# Resumen




# Métodos 

## Análisis de calidad de las lecturas y limpieza de adaptadores



### Análisis de  *raw data*

Para el análisis de calidad se usó fastqc de manera individual para cada data set
del SRA, y después se usó multiqc para visualizar en conjunto todos los resultados.


###  Limpieza de adaptadores

Para limpiar los adaptadores se usó el software trimmomatic en el siguiente 
bash script:

```
cd data
for i in *_1.fastq.gz;
do echo
trimmomatic PE -threads 8 -phred33 $i "${i%_1.fastq.gz}_2.fastq.gz" \
../data_trimmed/"${i%_1.fastq.gz}_1_trimmed.fastq.gz" ../data_trimmed/"${i%_1.fastq.gz}_1_unpaired.fastq.gz" \
../data_trimmed/"${i%_1.fastq.gz}_2_trimmed.fastq.gz" ../data_trimmed/"${i%_1.fastq.gz}_2_unpaired.fastq.gz" \
ILLUMINACLIP:../TruSeq3-PE.fa:2:30:10 LEADING:3 TRAILING:3 SLIDINGWINDOW:5:20 MINLEN:60
done
```

El script no es tan complicado, donde:

- ```./data``` es el directorio con todos los archivos crudos descargados de SRA.
- ```PE``` es para decir que el input sera un archivo paired end.
- ```phred33``` especifica la calidad de las bases.
- ```threads``` indica el número de núcleos que se van a utilizar.
- ```ILLUMINACLIP``` es para indicar los adaptadores y otras secuencias específicas de illumina.
- ```LEADING``` es para cortar las bases del comienzo de una lectura, si está por debajo de un umbral de calidad.
- ```TRAILING``` es para cortar las bases del final de una lectura, si está por debajo de un umbral de calidad.
- ```SLIDINGWINDOW``` recorta la lectura una vez que la calidad promedio dentro de la ventana cae por debajo de un umbral.
- ```MINLEN``` descarta la lectura si está por debajo de una longitud especificada.



### Analisis de calidad de las lecturas sin adaptadores

Se realizó el mismo procedimiento que con los datos crudos, pero ahora con las
lecturas sin adaptadores.


## Ensamblaje con el transcriptoma de referencia

Descargamos el transcriptoma de referencia en el directorio donde 
se correra kallisto, *i. e.*, en 
```/mnt/Timina/bioinfoII/rnaseq/BioProject_2023/rawData/COVID_virus``` con wget:

```
wget https://ftp.ebi.ac.uk/pub/databases/gencode/Gencode_human/release_43/gencode.v43.transcripts.fa.gz
```

Después, generamos el index de Kallisto con
```
kallisto index -i ./kallisto_quant/Hs_ref.kidx gencode.v43.transcripts.fa.gz
```

Posteriormente, se crearon directorios individuales para cada muestra dentro de 
```./kallisto_quant/```, ya que kallisto solo trabaja individualmente con cada
par de lecturas.

El pseudoalineamiento y cuantificacióncon kallisto se realizó para cada muestra con la siguiente
estructura:

```
kallisto quant -i ./kallisto_quant/Hs_ref.kidx -o ./kallisto_quant/SRR20114171 -t 25 ./data_trimmed/SRR20114171_1_trimmed.fastq.gz ./data_trimmed/SRR20114171_2_trimmed.fastq.gz
```

Donde ```-i``` indica el índice, ```-o``` el directorio de salida, ```-t```
el número de núcleos a usar y los otros dos archivos son el par de reads.

El output de kallisto son tres archivos: un json llamado ```un_info.json```,
un archivo de texto con las estimaciones de la abundancia llamado
```abundance.tsv``` y un archivo binario con información de la corrida, estimación
de la abundancia, estimados de bootstrap y longitud de los transcritos llamado
```abundance.h5 ```.


## Expresión diferencial

### Importación de los datos de kallisto

```{r libraries, include=FALSE}
library(tximport)
library(tidyverse)
library(DESeq2)
library(ggplot2)
library(ggrepel) # libreria que evita el overlap de texto en labels
library(rhdf5)
library(GenomicFeatures)
```


El primer paso para hacer en análisis de expresión diferencial fue importar los
datos de la cuantificación de kallisto. Para eso, antes hay que crear una tabla
```tx2gene```, que mapea genes con transcritos.

```{r tx2gene, warning=FALSE, message = FALSE}
## Creación del archivo tx2gene a partir de los archivos de anotación de 
## GENCODE. Se usó la versión 43, la misma usada durante el transcriptoma
## de referencia
txdb = makeTxDbFromGFF(file = "gencode.v43.chr_patch_hapl_scaff.annotation.gtf.gz")
#saveDb(x = txdb, file = "gencode.v43.basic.annotation.gtf.gz")
k = keys(txdb, keytype = "TXNAME")
tx2gene = select(txdb, k, "GENEID", "TXNAME")
head(tx2gene)
```


Ahora, ya podemos importar la información de kallisto:

```{r kallisto-import, message=FALSE}
## Guardado en una variable de los paths hacia los archivos h5
files = file.path(list.dirs("./kallisto_quant", recursive = FALSE),
                  "abundance.h5")
names(files) = str_extract(files, "SRR\\d+")

## Importación de la información
txi.kallisto.tsv = tximport(files, type = "kallisto", tx2gene = tx2gene,
                            ignoreAfterBar = TRUE)

## Conteos de los primeros transcritos
head(txi.kallisto.tsv$counts)
```

Ahora, hay que crear un objeto tipo data set de DESeq2, llamado DESeqDataSet.
DESeq2 necesita saber el tratamiento caso/control de cada muestra. Para saber eso,
descargamos la tabla de metadatos disponibles en 
[SRA Run Selector](https://www.ncbi.nlm.nih.gov/Traces/study/?acc=PRJNA858106&o=acc_s%3Aa),
con el nombre de ```metadata.csv```.


```{r dds-creation, warning=FALSE, message=FALSE}
## Importación de metadatos a R
meta = read.csv("metadata.csv", header = TRUE)
samples = column_to_rownames(meta, var = "Run")

## Creación del objeto DESeqDataSet
dds = DESeqDataSetFromTximport(txi.kallisto.tsv,
                               colData = samples,
                               design = ~disease_state)
```



## Análisis exploratorio

Primero, hay que pre-filtrar los conteos bajos, con el siguiente código:

```{r pre-filtering, message=FALSE, warning=FALSE}
## Pre-filtering
keep = rowSums(counts(dds)) >= 10
dds = dds[keep, ]

## Factor level
dds$disease_state = factor(dds$disease_state, levels = c("normal", "Covid-19"))
```

Para poder identificar algún *batch effect* se graficó un PCA, que se muestra en
la sección de resultados. Antes de relizar esa visualización, se normalizó
el objeto ```dds``` con la *variance stabilizing transformation*:

```{r variance-stabilizing-transformation, message=FALSE}
vst = vst(dds, blind = FALSE)
```





## DE

Una vez que vimos que no habían anomalías en el dataset, hicimos el análisis.
Para correr el análisis de expresión diferencial, se usa la siguiente función:

```{r DESeq, message=FALSE}
dds = DESeq(dds)
```


Los resultados del modelo son los siguientes, con un nivel de significancia de 
$\alpha=0.01$:

```{r res, }
res = results(dds, alpha = 0.01)
res
```





### Fer

```{r}
# library(biomaRt)
# ensembl = useEnsembl(biomart="ensembl", dataset="hsapiens_gene_ensembl")
# head(listAttributes(ensembl))
# head(listFilters(ensembl))
# ```
# ```{r echo=FALSE}
# library(tximport)
# library(tidyverse)
# library(DESeq2)
# library(ggplot2)
# library(ggrepel) # libreria que evita el overlap de texto en labels
# library(rhdf5)
# ```
# 
# ```{r}
# etID_egID <- getBM(attributes=c('ensembl_transcript_id','ensembl_gene_id'),  mart = ensembl) %>% relocate(ensembl_transcript_id)
# 
# etID_hgnc <- getBM(attributes=c('ensembl_transcript_id', 'hgnc_symbol'), mart = ensembl)
# ```
# 
# ```{r}
# # generar tabla de metadatos
# metadata.tsv <- data.frame("SRA" =c("SRR20114180","SRR20114179", "SRR20114178", "SRR20114177", "SRR20114176",
#                                           "SRR20114175", "SRR20114174", "SRR20114173", "SRR20114172", "SRR20114171"), "sample" = c("control_1","control_2","control_3", "patient_1", "patient_2", "patient_3", "patient_4", "patient_5", "patient_6", "patient_7") , "dex" = c(rep("control",3), rep("patient",7)), "species" = "Homo_sapiens")
# ```
# 
# ```{r}
# # Anotacion articulo
# # Cargar los archivos por nombre del archivo (ubicacion empleando la anotacion de los 224 transcriptomas) 
# samples <- metadata.tsv
# files   <- file.path("./kallisto_quant", samples$SRA,"abundance.tsv")
# names(files) <- samples$SRA
# ```
# 
# ```{r}
# # Load table with trx id and gene id corrspondence
# tx2gene <- etID_egID
# # Load table with trx id and gene name corrspondence
# tx2genename <- etID_hgnc
# 
# # Run tximport
# # tx2gene links transcript IDs to gene IDs for summarization
# txi.kallisto <- tximport(files, type = "kallisto", tx2gene = tx2gene, ignoreAfterBar=TRUE, ignoreTxVersion=TRUE)
# txi.kallisto.name <- tximport(files, type = "kallisto", tx2gene = tx2genename, ignoreAfterBar=TRUE, ignoreTxVersion=TRUE)
# ```
# 
# 
# ```{r}
# names(txi.kallisto)
# ```
# 
# ```{r}
# head(txi.kallisto$counts)
# ```
# 
# ```{r}
# # nombre de los transcriptomas
# rownames(samples) <- samples$sample
# colnames(txi.kallisto$counts) <-rownames(samples) 
# ```
# 
# ```{r echo=FALSE}
# # Importacion de los datos convirtiendolos en un objeto que puede leer Deseq.
# ddsTxi_all <- DESeqDataSetFromTximport(txi.kallisto, samples, design = ~ dex) # Create a DESeq object from the tximport data
# ```
# 
# ```{r echo=FALSE}
# # Prefiltrado, eliminacion de genes con bajas cuentas
# keep  <- rowSums(counts(ddsTxi_all)) >= 10
# ddsTxi_all  <- ddsTxi_all[keep,] 
# dds_all <- DESeq(ddsTxi_all) # run Differential expression analysis
# ```
# 
# ```{r}
# res <- results(dds_all)
# res
# ```
# 
# ```{r}
# summary(res)
# ```

```{r}
# resSig <- subset(res, padj < 0.1) # subset
# head(resSig[ order(resSig$log2FoldChange), ]) # more downregulated genes
# head(resSig[ order(resSig$log2FoldChange, decreasing = TRUE), ]) # genes more upregulated
```

### Expresion diferencial (TODOS LOS TRANSCRITOS)

```{r}
# # extraer UP
# all_de_gene_matrix_UP  <- subset(res, padj < 0.05 & log2FoldChange >= 2)
# write.table(all_de_gene_matrix_UP,file ="./all_DEG_kallisto_Patients.tsv", quote=FALSE, sep="\t")
# # Extraer nombres
# all_de_gene_names_UP <- rownames(all_de_gene_matrix_UP)
# 
# # extraer down genes
# all_de_gene_matrix_DOWN  <- subset(res, padj < 0.05 & log2FoldChange < -2)
# write.table(all_de_gene_matrix_DOWN,file ="./all_DEG_kallisto_Control.tsv", quote=FALSE, sep="\t")
# # Extraer nombres
# all_de_gene_names_DOWN <- rownames(all_de_gene_matrix_DOWN)
# 
# # Numero de genes expresados
# length(all_de_gene_names_UP)
# length(all_de_gene_names_DOWN)
# ```
# 
# # Visualización gráfica
# 
# **Cuentas normalizadas para graficas (rlog)**
# ```{r}
# all_normalized <- rlog(dds_all, blind=FALSE) # result rld, vst
# all_normalized_db <- as.data.frame(assay(all_normalized))
# head(all_normalized_db)
# ```
# 
# ## PCA
# ```{r}
# vst = vst(dds, blind = FALSE)
# plotPCA(vst, intgroup = "disease_state")
# ```
# 
# ## Volcano plot
# ```{r}
# de <- as.data.frame(res_all)
# # add a column of NAs
# de$diffexpressed <- "NO"
# 
# # if log2Foldchange > 0.6 and pvalue < 0.05, set as "UP" 
# de$diffexpressed[de$log2FoldChange > 2 & de$pvalue < 0.05] <- "UP"
# # if log2Foldchange < -0.6 and pvalue < 0.05, set as "DOWN"
# de$diffexpressed[de$log2FoldChange < -2 & de$pvalue < 0.05] <- "DOWN"
# # Create a new column "names" to de, that will contain the name of a subset if genes differentially expressed (NA in case they are not)
# de$names <- NA
# # filter for a subset of interesting genes
# filter <- which(de$diffexpressed != "NO" & de$padj < 0.05 & (de$log2FoldChange >= 5  | de$log2FoldChange <= -5))
# de$names[filter] <- rownames(de)[filter]
# 
# # grafica
# png(file = "volcano-COVID.png",
#     width = 800, height = 800) # guardar el plot en formato png
# ggplot(data=de, aes(x=log2FoldChange, y=-log10(pvalue), col=diffexpressed, label=names)) +
#     geom_point() +
#     scale_color_manual(values=c("blue", "black", "red")) + # cambiar colores de puntos
#     theme_minimal() +
#     geom_text_repel() +
#     xlim(-15,15)
# dev.off()
```

## Heatmap
```{r}
# library("pheatmap")
# # los primeros 20 genes
# select <- order(rowMeans(counts(dds_all,normalized=TRUE)),
#                 decreasing=TRUE)[1:20]
# df <- as.data.frame(colData(dds_all)[,c("dex", "sample")])
# 
# #heatmap
# pheatmap(assay(all_normalized)[select,], cluster_rows=FALSE, show_rownames=FALSE,
#          cluster_cols=FALSE, annotation_col=df)
```

# Resultados


## Análisis de calidad de datos crudos


Todo el resumen de la calidad de los datos crudos se encuentra [aquí](QC/QC_rawData/multiqc_report.html).


Todos los resultados se encuentran dentro del DNA HPCC en la ruta siguiente ruta:
```
/mnt/Timina/bioinfoII/rnaseq/BioProject_2023/rawData/COVID_virus/FastQC_rawData
```




## Análisis de calidad de los datos sin adaptadores



Como podemos ver en la siguiente gráfica, la calidad media de cada base de
las reads es en general buena.

![](QC/QC_trimmedData/fastqc_per_base_sequence_quality_plot.png)


También podemos ver que la calidad media de las *reads* igualmente es buena.

![](QC/QC_trimmedData/fastqc_per_sequence_quality_scores_plot.png)

El contenido de GC es complicado, pero como estamos analizando datos de 
transcripción, toleraremos que hayan varios picos y distribuciones no normales.

![](QC/QC_trimmedData/fastqc_per_sequence_gc_content_plot.png)


La calidad de secuenciación es de un nivel tal que la existencia lecturas N 
es casi nula.


![](QC/QC_trimmedData/fastqc_per_base_n_content_plot.png)


La longitud de las secuencias si bien no es perfecta, es aceptable. Además, 
son secuencias largas, por lo que el alineamiento será mejor.

![](QC/QC_trimmedData/fastqc_sequence_length_distribution_plot.png)


En cuanto a lecturas duplicadas, hay muchas que se repiten; lo cual tiene sentido,
ya que estamos anlizando datos de transcripción.

![](QC/QC_trimmedData/fastqc_sequence_duplication_levels_plot.png)

Todos los resultados, tanto individuales de cada fastqc como del multiqc, se encuentran
dentro del DNA HPCC en la ruta:
```
/mnt/Timina/bioinfoII/rnaseq/BioProject_2023/rawData/COVID_virus/FastQC_trimmed
```


## Análisis exploratorio

### PCA

```{r PCA, echo=FALSE}
plotPCA(vst, intgroup = "disease_state")
```



## DE

### MA-plot


```{r MA-plot}
plotMA(res)
```



### Volcano plot






```{r volcano, warning=FALSE}

de = as.data.frame(res)

de$diffexpressed = "NO"

de$diffexpressed[de$log2FoldChange > 0.6 & de$pvalue < 0.01] <- "UP"

de$diffexpressed[de$log2FoldChange < -0.6 & de$pvalue < 0.01] <- "DOWN"



ggplot(data = de, aes(x=log2FoldChange, y=-log10(pvalue), col=diffexpressed)) + 
  geom_point() 
  
```




# Discusión







